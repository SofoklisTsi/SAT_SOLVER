# SAT Solver

This project is an implementation of a SAT (Boolean Satisfiability) solver using the **DPLL (Davis-Putnam-Logemann-Loveland)** algorithm in Python.

## Project Structure

``` text
    SAT_SOLVER/
    ├── src/sat_solver
    |   ├── Solver/
    |   │   └── dpll_solver.py                # DPLL algorithm implementation.
    |   │   └── cdcl_solver.py                # CDCL algorithm implementation.
    |   ├── SATProblems/
    |   │   ├── sat_problem.py                # SAT problem representation.
    |   │   ├── twl_sat_problem.py            # Two Watched Literals (TWL) SAT problem representation.
    |   |   └── true_twl_sat_problem,py       # True Two Watched Literals (TWL) SAT problem representation.
    |   ├── Heuristics/
    |   │   ├── literal_count_branching_heuristics.py  # Literal count heuristics (Default, DLCS, DLIS, RDLCS, RDLIS).
    |   │   └── moms_branching_heuristics.py           # MOM’s and RMOM’s heuristics.
    |   ├── DIMACS_Reader/
    |   │   ├── clauses_model.py             # Model for DIMACS clauses, used to initialize the dpll_solver.
    |   │   └── clause_reader.py             # Logic for reading DIMACS CNF files.
    |   ├── Loggers/
    |   │   ├── cdcl_logger.py             # Logger for the graph steps of the cdcl_solver.
    |   │   └── step_logger.py             # Step logger for each step of the solvers.    
    |   ├── DATA/
    |   │   ├── Clauses_Files/
    |   │   │   ├── Clauses_Files_Results/
    |   │   │   │   ├── PDFS_Results/       # Results for the pdf problems.
    |   │   │   │   └── TESTS_Results/      # Testing results.
    |   │   │   ├── PDFS/                   # SAT problem files in CNF format from the university's PDFs.
    |   │   │   └── TESTS/                  # Test files created to test different aspects of the project.
    |   │   ├── SATLIB/                     # Standard SAT problem instances from [SATLIB](https://www.cs.ubc.ca/~hoos/SATLIB/benchm.html).
    |   │   │   ├── uf100-430/              
    |   │   │   ├── uf125-538/              # Each folder contains 10 .cnf problems.
    |   │   │   ├── uf150-645/
    |   │   │   ├── uf20-91/
    |   │   │   ├── uf250-1065/
    |   │   │   └── uf75-325/
    |   ├── Testers/
    |   │   ├── profile_output.prof          # Profiling output that will be created by test_SATLIB.py.
    |   │   ├── test_dpll_solver.py          # Unit tests for DPLL solver.
    |   │   ├── test_SATLIB.py               # Unit tests for SATLIB instances and Profiling.
    |   │   └── dpll_version_tester.py            # Version testing to ensure the functionality of the DPLL Solver after each change.
    |   │   └── cdcl_version_tester.py            # Version testing to ensure the functionality of the CDCL Solver after each change.    
    ├── pyproject.toml                   # Poetry configuration file for dependencies and project settings.
    ├── poetry.lock                      # Dependency lockfile generated by Poetry.
    ├── .gitignore                       # Git ignore configuration.
    └── README.md                        # Project documentation. This very file!
```

## Features

- **DPLL Algorithm**: Implements the DPLL algorithm with optional pure literal elimination and unit propagation.
- **Logging and Decision Table**: Logs each decision step, including decision literals, implied literals, satisfied/contradicted clauses, and explanations.
- **Configurable Options**: Includes settings for using or skipping pure literal elimination, different heuristics and two watched literals.
- **Unit Tests**: Basic tests for the solver using `test_dpll_solver.py`.
- **Version Tests**: A list of tests for testing the solvers functionality using `version_tester.py`.
- **Benchamarks Tester**: A list of the instance the solver can solver and the solvers profiling using `test_SATLIB.py`

### Phase 2.1: Literal Count Heuristics and Clause Elimination Preparation

- **Literal Count Heuristics**: Adds branching heuristics (DLCS, DLIS, RDLCS, RDLIS) based on literal counts to guide decision-making, improving solver efficiency.
- **Clause Elimination Preparation**: Moved `pure_literal_elimination` to `clause_elimination_methods.py`, establishing a modular structure for future clause elimination techniques.

### Phase 2.2: Add MOM’s Heuristics

- **MOM's Heuristic**: Implements the Maximum Occurrences on clauses of Minimum size (MOM's) heuristic, which selects literals based on their frequency in the smallest unsatisfied clauses. MOM's heuristic uses a formula to prioritize literals that occur frequently, controlled by the parameter `k`.
- **RMOM's Heuristic**: Randomized version of MOM's, assigning a randomly chosen truth value (True/False) to the selected literal.
- **Flexible `k` Parameter**: Allows the user to adjust the sensitivity of MOM's heuristic through the `k` parameter, which influences literal selection. 

### Phase 3.0: Two Watched Literals (TWL) Optimization

- **Two Watched Literals**: Implements the Two Watched Literals optimization to improve unit propagation efficiency. By monitoring only two literals in each clause, this approach minimizes the number of literals checked at each decision level, making the solver more efficient for larger problems.
- **Integration with DPLL**: When twl=True is enabled, the solver converts the SAT problem instance to use the Two Watched Literals technique, making it compatible with the existing DPLL logic.

### Phase 3.1: DIMACS Clause Form Compatibility and Code Refactoring

- **DIMACS Reader**: A class that processes DIMACS .cnf files, extracting the problem's clauses, the number of literals, and the number of clauses for use in the solver.
- **Performance Testing**: Utilized cProfile and SnakeViz to benchmark the solver's performance with various SATLIB problem instances. This phase helped identify performance bottlenecks and areas for optimization.
- **Code Refactoring**: Following the performance analysis, significant changes were made to the codebase to optimize the solver's efficiency. While these improvements enhanced performance, they resulted in a decrease in code readability. 
- **Enhanced Project Structure**: As the project expanded, the code was reorganized into dedicated directories and modules to maintain clarity and manageability. This restructuring ensures easier navigation and scalability for future development.
- **Decision Literal Bug Fixed**: A bug was identified where the decision literal printed in the 'decision literal' column of the 'steps' log had incorrect polarity when heuristics other than the 'default' were used. This issue has now been resolved.

### Phase 3.2: PyPy, Poetry, Pytest and Code Refactoring
- **Project's Directory Changes**: The codebase and data files have been reorganized to improve structure and scalability. All source code and related modules are now housed in the src/sat_solver directory.
- **True Two Watched Literals**: Introduced `TrueTWLSATProblem`, a novel variation of the Two Watched Literals (TWL) optimization. This implementation provides an alternative mechanism for managing watched literals, offering potential performance improvements for certain SAT problem instances.
- **PyPy**: Full compatibility with `PyPy 3.10` has been achieved. PyPy significantly enhances runtime performance, making the solver more efficient for larger or more complex SATLIB problems.
- **Poetry**: The project now leverages Poetry for dependency management, virtual environments, and packaging. Key benefits include:
    - Simplified dependency installation with the poetry install command.
    - Isolated environments for better control over package versions and compatibility.
    - Easy configuration through the pyproject.toml file, which also defines metadata like the project's name, version, and supported Python versions.
- **Pytest**: Testing workflows have been modernized with Pytest, enabling:
    - Parametrized tests for heuristics and features, ensuring comprehensive coverage.
    - Simplified test discovery and execution with the poetry run pytest command.
    - Integration of fixtures for reusable test setups, improving maintainability and readability.

### Phase 3.2.1: Pydantic, Paths, and BCP/is_unsatisfied Logic Change 
- **Path Configuration Fix**: Resolved module import issues by addressing incorrect path configurations. Ensure your working directory is set to src/sat_solver during execution to avoid errors.
- **BCP Optimization**: Improved Boolean Constraint Propagation (BCP) logic for better performance.
- **is_unsatisfied Optimization**: Enhanced logic for detecting unsatisfied clauses, reducing overhead.
- **Pydantic Integration**: Structured and validated configurations using Pydantic for better robustness.
- **Pure Literal Elimination (PLE) Removal**: As outlined in previous phases, Pure Literal Elimination has now been fully deprecated and removed from the solver. Starting with this version, PLE is no longer supported, reflecting a shift towards more modern and efficient SAT solving techniques.

### Phase 4.0: CDCL Basic
- **CDCL Solver**: The first version of the CDCL algorithm has been implemented. This version is compatible with all available heuristics but does not yet support the Two Watched Literal scheme or its variation, TrueTWL. It exclusively uses the 1UIP (First Unique Implication Point) cutting method.
- **Loggers Folder**: The logging functionality, previously embedded within the DPLLSolver class, has been modularized into its own set of classes. These loggers are now shared between the DPLL and CDCL solvers.
- **CDCL Logger**: A new specialized logger for the CDCL solver has been introduced. It tracks the implication graph, which is critical for understanding and debugging the solver's decision-making process.
- **Data Folder**: A new directory has been added to organize test cases and test results for the CDCL solver. This folder ensures proper tracking and versioning of test data.
- **DPLL Version Tester**: The existing version tester has been renamed for clarity, reflecting its specialization for testing the DPLL solver.
- **CDCL Version Tester**: A new testing framework specifically designed to validate the functionality of the CDCL solver. It supports automated testing of various heuristics and configurations.
- **SATProblem Changes**: A new method, add_clauses, has been added to the SATProblem class to enable the dynamic addition of clauses. This change ensures proper compatibility with the CDCL solver.
- **Code Refactoring**: Significant improvements have been made to the DPLL solver codebase to enhance readability and maintainability. Large blocks of logic have been broken down into smaller, more manageable methods.

## Requirements

- Python 3.10 (in order to be compatioble with PyPy)
- [Git](https://git-scm.com/) for version control
- [PyPy 3.10](https://www.pypy.org/) for enhanced performance (recommended).
- [Poetry](https://python-poetry.org/) for dependency and environment management.

## Setup

1. Clone the repository:
    ```bash
    git clone https://github.com/SofoklisTsi/SAT_SOLVER.git
    cd SAT_SOLVER
    ```

2. Install PyPy:
    Download PyPy 3.10 from the [official website](https://www.pypy.org/).

3. Install Poetry:
    Follow the [Poetry installation guide](https://python-poetry.org/docs/).

4. Configure PyPy and Poetry for the Project:
    ```bash
    poetry install
    poetry env use C:\PyPy\pypy3.10-v7.3.17-win64\pypy3.10.exe (or your path to pypy)

## Usage

1. To solve a SAT problem:
    ```python
    from sat_solver.DIMACS_Reader.clauses_model import ClausesModel
    from sat_solver.Solver.dpll_solver import DPLLSolver

    clauses = [[1, -3, 0], [-2, 3, 0], [2, 4, 0], [-4, 0]]  # Example problem
    num_of_clauses = 4
    num_of_variables = 4
    clauses_model = ClausesModel(clauses=clauses, num_clauses=num_of_clauses, num_vars=num_of_variables)

    solver = DPLLSolver(clauses_model=clauses_model, use_logger=True, heuristic='moms', k=2, twl=False)

    is_satisfiable = solver.solve()
    print("Satisfiable:", is_satisfiable)

    # Print decision steps (optional)
    solver.print_steps()
    ```

2. **Selecting Heuristics**:
   The solver supports multiple heuristics, which can be set via the `heuristic` parameter in `DPLLSolver`. Options include:
   - `'default'`: A simple first unassigned literal heuristic.
   - `'dlcs'`, `'dlis'`, `'rdlcs'`, `'rdlis'`: Literal count-based heuristics.
   - `'moms'`: MOM’s heuristic, with configurable `k` (e.g., `heuristic='moms', k=2`).
   - `'rmoms'`: RMOM’s heuristic, which randomizes the truth value of the selected literal (e.g., `heuristic='rmoms', k=2`).

3. **Two Watched Literals (TWL)**:
    To enable Two Watched Literals, pass twl=True when initializing DPLLSolver.
    To enable True Two Watched Literals, pass true_twl=True when initializing DPLLSolver.

4. **Testing**:
   Run tests to verify the solver works correctly:
   ```bash
    poetry shell  # Activates the Poetry environment
    cd src/sat_solver
    pytest -v testers/version_tester.py  # Run tests
    pytest -v -s testers/version_tester.py  # Include logger output during test runs
    exit # Exits the Poetry environment
   ```

5. **Performance Testing**:
   To test the solver's performance, use the test_SATLIB.py script. This will profile the solver's execution using cProfile, which can then be visualized with SnakeViz. To do so, run the following commands:
   ```bash
    poetry shell  # Activates the Poetry environment
    cd src/sat_solver
    pypy testers/test_SATLIB.py # Execute tests with PyPy for performance comparison
    snakeviz testers/profile_output.prof  # This opens a visualization of the profiling data
    exit # Exits the Poetry environment
   ```

## Acknowledgements
A special thanks to the creator of the [Folder Mapper VSCode Extension](https://github.com/m0n0t0ny/Folder-Mapper-VSCode-Extension). This extension has been incredibly helpful in organizing and visualizing the project structure, as well as in explaining it to AI tools.
